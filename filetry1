keyword list = {"null","NULL","and", "and_eq", "bitand", "bitor", "cmpl", "not", "not_eq", "or", "or_eq", "xor", "xor_eq", "noexcept", "nullptr", "asm", "auto", "register", "thread_local", "volatile", "bool", "true", "false", "void", "int", "signed", "unsigned", "long", "short", "unsigned int", "signed int", "short int", "unsigned short int", "signed short int", "long int", "unsigned long int", "signed long int", "float", "double", "long double",  "char", "char16_t", "char32_t", "unsigned char", "signed char", "wchar_t", "enum", "sizeof", "typedef", "typeid", "typename", "template", "break", "do", "for", "while", "continue", "if", "else", "switch", "case", "default", "goto", "try", "throw", "catch", "class", "public", "private", "protected", "static", "static_assert", "static_cast", "this", "operator", "struct", "alignas", "alignof", "alignment_of", "new", "delete", "union", "mutable", "const", "constexpr", "const_cast", "dynamic_cast", "reinterpret_cast", "explicit", "export", "extern", "friend", "inline", "namespace", "using", "return", "virtual", "decltype", "override", "final","cin","cout"}

alphabetL  [a-z]
alpabhetU	[A-Z]
digit		[0-9]
underscore	[_]
whitespace	[ \t]
newline		[ \n]
identifier	{alphabetL|underscore}({alphabetL|alphabetU|underscore|digit})*
pointer		"*"{identifier}
array		{identifier}("["{digit}*"]")*

decimal		[1-9]{digit}+
octal     "0"{digit}+
hexadecimal  {"0x"|"$"}{digit|[A-Fa-f]}+

unsigneddecimal {decimal}{"u"|"U"}
longdecimal     {decimal}{"l"|"L"}
unsignedlongdecimal {decimal}{"ul"|"UL"}

realdecimal		{decimal}"."{digit}*
realoctal     {octal}"."{octal}*
realhexadecimal {hexadecimal}"."{digit|[A-Fa-f]}+

scientificdecimal {decimal|realdecimal}+"E"{"+"|"-"}?{decimal}
scientificoctal   {octal|realoctal}+"E"{"+"|"-"}?{octal}
scientifichexadecimal {hexadecimal|realhexadecimal}+"E"{"+"|"-"}?{digit|[A-Fa-f]}+

string		".*"
comment     ("/*"(.*)"*/")|("//"(.*)"/n")

macros  "#define "
headerfile  "#include "("<"|"){string}(">"|")

%

"asm"              return(TOK_ASM);
"auto"             return(TOK_AUTO);
"break"            return(TOK_BREAK);
"bool"             return(TOK_BOOL);
"case"             return(TOK_CASE);
"catch"            return(TOK_CATCH);
"cdecl"            return(TOK_CDECL);
"char"             return(TOK_CHAR);
"class"            return(TOK_CLASS);
"const"            return(TOK_CONST);
"const_cast"       return(TOK_CONST_CAST);
"continue"         return(TOK_CONTINUE);
"default"          return(TOK_DEFAULT);
"delete"           return(TOK_DELETE);
"do"               return(TOK_DO);
"double"           return(TOK_DOUBLE);
"dynamic_cast"     return(TOK_DYNAMIC_CAST);
"else"             return(TOK_ELSE);
"enum"             return(TOK_ENUM);
"explicit"         return(TOK_EXPLICIT);
"export"           return(TOK_EXPORT);
"extern"           return(TOK_EXTERN);
"false"            return(TOK_FALSE);
"float"            return(TOK_FLOAT);
"for"              return(TOK_FOR);
"friend"           return(TOK_FRIEND);
"goto"             return(TOK_GOTO);
"if"               return(TOK_IF);
"inline"           return(TOK_INLINE);
"int"              return(TOK_INT);
"long"             return(TOK_LONG);
"mutable"          return(TOK_MUTABLE);
"namespace"        return(TOK_NAMESPACE);
"new"              return(TOK_NEW);
"operator"         return(TOK_OPERATOR);
"pascal"           return(TOK_PASCAL);
"private"          return(TOK_PRIVATE);
"protected"        return(TOK_PROTECTED);
"public"           return(TOK_PUBLIC);
"register"         return(TOK_REGISTER);
"reinterpret_cast" return(TOK_REINTERPRET_CAST);
"return"           return(TOK_RETURN);
"short"            return(TOK_SHORT);
"signed"           return(TOK_SIGNED);
"sizeof"           return(TOK_SIZEOF);
"static"           return(TOK_STATIC);
"static_cast"      return(TOK_STATIC_CAST);
"struct"           return(TOK_STRUCT);
"switch"           return(TOK_SWITCH);
"template"         return(TOK_TEMPLATE);
"this"             return(TOK_THIS);
"throw"            return(TOK_THROW);
"true"             return(TOK_TRUE);
"try"              return(TOK_TRY);
"typedef"          return(TOK_TYPEDEF);
"typeid"           return(TOK_TYPEID);
"typename"         return(TOK_TYPENAME);
"union"            return(TOK_UNION);
"unsigned"         return(TOK_UNSIGNED);
"using"            return(TOK_USING);
"virtual"          return(TOK_VIRTUAL);
"void"             return(TOK_VOID);
"volatile"         return(TOK_VOLATILE);
"wchar_t"          return(TOK_WCHAR_T);
"while"            return(TOK_WHILE);

"("                return (TOK_LPAREN);
")"                return (TOK_RPAREN);
"["                return (TOK_LBRACKET);
"]"                return (TOK_RBRACKET);
"->"               return (TOK_ARROW);
"::"               return (TOK_COLONCOLON);
"."                return (TOK_DOT);
"!"                return (TOK_BANG);
"~"                return (TOK_TILDE);
"+"                return (TOK_PLUS);
"-"                return (TOK_MINUS);
"++"               return (TOK_PLUSPLUS);
"--"               return (TOK_MINUSMINUS);
"&"                return (TOK_AND);
"*"                return (TOK_STAR);
".*"               return (TOK_DOTSTAR);
"->*"              return (TOK_ARROWSTAR);
"/"                return (TOK_SLASH);
"%"                return (TOK_PERCENT);
"<<"               return (TOK_LEFTSHIFT);
">>"               return (TOK_RIGHTSHIFT);
"<"                return (TOK_LESSTHAN);
"<="               return (TOK_LESSEQ);
">"                return (TOK_GREATERTHAN);
">="               return (TOK_GREATEREQ);
"=="               return (TOK_EQUALEQUAL);
"!="               return (TOK_NOTEQUAL);
"^"                return (TOK_XOR);
"|"                return (TOK_OR);
"&&"               return (TOK_ANDAND);
"||"               return (TOK_OROR);
"?"                return (TOK_QUESTION);
":"                return (TOK_COLON);
"="                return (TOK_EQUAL);
"*="               return (TOK_STAREQUAL);
"/="               return (TOK_SLASHEQUAL);
"%="               return (TOK_PERCENTEQUAL);
"+="               return (TOK_PLUSEQUAL);
"-="               return (TOK_MINUSEQUAL);
"&="               return (TOK_ANDEQUAL);
"^="               return (TOK_XOREQUAL);
"|="               return (TOK_OREQUAL);
"<<="              return (TOK_LEFTSHIFTEQUAL);
">>="              return (TOK_RIGHTSHIFTEQUAL);
","                return (TOK_COMMA);
"..."              return (TOK_ELLIPSIS);
";"                return (TOK_SEMICOLON);
"{"                return (TOK_LBRACE);
"}"                return (TOK_RBRACE);

  /* "alternative tokens" of cppstd 2.5p2 */
"<%"               return alternateKeyword_tok(TOK_LBRACE);
"%>"               return alternateKeyword_tok(TOK_RBRACE);
"<:"               return alternateKeyword_tok(TOK_LBRACKET);
":>"               return alternateKeyword_tok(TOK_RBRACKET);
  /* "%:" and "%:%:" correspond to "#" and "##", which are only for
   * the preprocessor, so I will ignore them here */
"and"              return alternateKeyword_tok(TOK_ANDAND);
"bitor"            return alternateKeyword_tok(TOK_OR);
"or"               return alternateKeyword_tok(TOK_OROR);
"xor"              return alternateKeyword_tok(TOK_XOR);
"compl"            return alternateKeyword_tok(TOK_TILDE);
"bitand"           return alternateKeyword_tok(TOK_AND);
"and_eq"           return alternateKeyword_tok(TOK_ANDEQUAL);
"or_eq"            return alternateKeyword_tok(TOK_OREQUAL);
"xor_eq"           return alternateKeyword_tok(TOK_XOREQUAL);
"not"              return alternateKeyword_tok(TOK_BANG);
"not_eq"           return alternateKeyword_tok(TOK_NOTEQUAL);

%

